---
title: "BANC Connectome Analysis with influencer"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{BANC Connectome Analysis with influencer}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/vignette-",
  fig.width = 8,
  fig.height = 6,
  warning = FALSE,
  message = FALSE
)
```

> **Note**: This vignette uses the BANC connectome data which requires authentication tokens to access. The code chunks are set to `eval=FALSE` to prevent build failures in automated environments. To run this analysis yourself, you'll need to set up access to the BANC data through the `bancr` package.

## Introduction

This vignette demonstrates how to use the `influencer` package to analyze connectome data, specifically focusing on the **BANC** (Brain And Nerve Cord) connectome. The BANC connectome represents the first complete connectome of both brain and ventral nerve cord in a limbed animal - *Drosophila melanogaster*.

We'll analyze how **DNa03** descending neurons influence other neurons in the network using the native R implementation of connectome influence calculation.

## Setup

```{r setup}
library(influencer)
library(dplyr)
library(ggplot2)

# Suppress default PDF output
pdf(NULL)

# Set random seed for reproducibility
set.seed(42)
```

## Loading Real BANC Data

We'll use the `bancr` package to load actual BANC connectome data:

```{r create_data, eval=FALSE}
# Install bancr package for BANC connectome data access
# remotes::install_github('flyconnectome/bancr')

library(bancr)

# Load BANC cell type annotations from the centralised codex
banc.meta <- banc_codex_annotations() %>%
  mutate(
    root_id = as.character(pt_root_id),           # Convert integer64 to character for SQLite compatibility
    pt_root_id = as.character(pt_root_id),        # Convert integer64 to character
    pt_supervoxel_id = as.character(pt_supervoxel_id)  # Convert integer64 to character
  ) %>%
  select(-pt_position)  # Remove complex arrow_list column that causes SQLite issues

# Focus analysis on descending neurons that connect brain to VNC
dn.ids <- banc.meta %>% 
  filter(super_class == "descending") %>%
  pull(root_id) %>%
  as.character()

cat("Total neurons in BANC:", nrow(banc.meta), "\n")
cat("Descending neurons:", length(dn.ids), "\n")
cat("DNa03 neurons:", sum(banc.meta$cell_type == "DNa03", na.rm = TRUE), "\n")
cat("DNa06 neurons:", sum(banc.meta$cell_type == "DNa06", na.rm = TRUE), "\n")
```

Now let's load the actual BANC connectivity data:

```{r create_edges, eval=FALSE}
# Load the complete BANC connectivity matrix (this may take several minutes)
cat("Loading BANC edge list (this may take a few minutes)...\n")
banc.edges <- banc_edgelist()

# Create edge list with synapse counts and postsynaptic-normalisation
# This normalisation step helps calibrate for neuron size and connection number
# i.e. a neuron with more inputs likely needs more of them 'activated' to have an effect
edges.table <- banc.edges %>%
  select(pre = pre_pt_root_id, post = post_pt_root_id, count = n) %>%
  group_by(post) %>%
  mutate(post_count = sum(count, na.rm=TRUE)) %>%
  mutate(norm = round(count/post_count,4)) %>%
  ungroup() %>%
  mutate(pre = as.character(pre),
         post = as.character(post)) %>%
  filter(count > 5)  # Apply synapse count threshold

cat("Loaded", nrow(edges.table), "edges from BANC connectome\n")
head(edges.table)
```

## Influence Calculation

Now we'll use the native R implementation to calculate connectome influence:

```{r create_calculator}
# Create influence calculator using native R implementation
ic.dns <- influence_calculator_r(edgelist_simple = edges.table, meta = banc.meta)

# Select DNa03 descending neurons as our seed population
dna03.ids <- banc.meta %>% 
             filter(cell_type == "DNa03") %>%
             pull(pt_root_id) %>%
             as.character()

cat("DNa03 seed IDs:", paste(dna03.ids, collapse = ", "), "\n")
```

Let's identify the direct targets of DNa03 neurons:

```{r direct_targets, eval=FALSE}
# Get direct targets of DNa03 neurons
dna03.post.ids <- edges.table %>%
                  filter(pre %in% dna03.ids) %>%
                  pull(post) %>%
                  unique() %>%
                  as.character()

cat("Direct targets of DNa03:", length(dna03.post.ids), "neurons\n")
```

Now calculate the influence scores:

```{r calculate_influence, eval=FALSE}
# Calculate how DNa03 neurons influence other neurons (long compute the FIRST time, ~30mins, but then decomposition is cached)
system.time({
  dna03.influence <- ic.dns$calculate_influence(dna03.ids)
})
# ~23 minutes for the first calculation on the full BANC connectome (1.1M edges, 114K neurons)

cat("Calculated influence for", nrow(dna03.influence), "neurons\n")

# Show the structure of results
head(dna03.influence)
```

## Data Analysis and Visualization

Let's classify neurons by whether they're directly or indirectly connected to our seed neurons:

```{r classify_connections, eval=FALSE}
# Classify neurons by their direct connection to seeds
dna03.influence$directly_connected <- dna03.influence$id %in% dna03.post.ids

# Summary statistics
table(dna03.influence$directly_connected)
```

Now we can create visualizations to explore the influence patterns:

```{r plot_influence, eval=FALSE, fig.width=10, fig.height=6}
# Create density plot showing influence patterns with scaled densities
g1 <- ggplot(dna03.influence, aes(x = adjusted_influence, 
                                  fill = directly_connected)) +
  geom_density(alpha = 0.7, color = NA, position = "identity", 
               aes(y = after_stat(density))) +
  scale_fill_manual(values = c("FALSE" = "#007BC3", 
                               "TRUE" = "#EE4244"),
                    labels = c("indirectly connected", "directly connected")) +
  labs(title = "DNa03 influence onto other descending neurons",
       subtitle = "adjusted influence onto directly connected and indirectly connected targets",
       x = "adjusted influence score", 
       y = "density",
       fill = "Connection type") +
  theme_minimal() +
  theme(legend.position = "bottom")

print(g1)

# Save plot
# Create directory if it doesn't exist (for R CMD check)
if (!dir.exists("inst/images")) {
  dir.create("inst/images", recursive = TRUE)
}
ggsave(g1, 
    file = "inst/images/banc_dna03_influence_r.png", 
    height = 6, 
    width = 8)
```

## Demonstrating Performance Caching

Now that we have run the first influence calculation, the expensive matrix decomposition should be cached. Let's demonstrate this by calculating influence for a different cell type (DNa06) - this should be much faster:

```{r caching_demo, eval=FALSE, fig.width=10, fig.height=6}
# Get DNa06 IDs from real BANC data
dna06.ids <- banc.meta %>%
             filter(cell_type == "DNa06") %>%
             pull(pt_root_id) %>%
             as.character()

cat("DNa06 seed IDs found:", length(dna06.ids), "\n")

# Get direct targets of DNa06 neurons
dna06.post.ids <- edges.table %>%
                  filter(pre %in% dna06.ids) %>%
                  pull(post) %>%
                  unique() %>%
                  as.character()

cat("Direct targets of DNa06:", length(dna06.post.ids), "neurons\n")

# Calculate how DNa06 neurons influence other neurons
system.time({
  dna06.influence <- ic.dns$calculate_influence(dna06.ids)
})
# ~0.39 seconds, 3500x speedup for subsequent calculations with different seeds but the same connectivity matrix
dna06.influence$directly_connected <- dna06.influence$id %in% dna06.post.ids

cat("Calculated influence for", nrow(dna06.influence), "neurons (cached calculation)\n")

# Get direct targets for both DNa03 and DNa06
dna03.post.ids <- edges.table %>%
                  filter(pre %in% dna03.ids) %>%
                  pull(post) %>%
                  unique() %>%
                  as.character()

dna06.post.ids <- edges.table %>%
                  filter(pre %in% dna06.ids) %>%
                  pull(post) %>%
                  unique() %>%
                  as.character()

# Merge results for comparison
comparison_data <- merge(
  dna03.influence[, c("id", "adjusted_influence")],
  dna06.influence[, c("id", "adjusted_influence")],
  by = "id",
  suffixes = c("DNa03", "DNa06")
)

# Add detailed direct connection information for both DNa03 and DNa06
comparison_data$direct_to_DNa03 <- comparison_data$id %in% dna03.post.ids
comparison_data$direct_to_DNa06 <- comparison_data$id %in% dna06.post.ids

# Create detailed connection categories
comparison_data$connection_type <- case_when(
  comparison_data$direct_to_DNa03 & comparison_data$direct_to_DNa06 ~ "Both-direct",
  comparison_data$direct_to_DNa03 & !comparison_data$direct_to_DNa06 ~ "DNa03-direct",
  !comparison_data$direct_to_DNa03 & comparison_data$direct_to_DNa06 ~ "DNa06-direct",
  TRUE ~ "Indirect"
)

# Order data frame so indirect points are plotted first (will be covered by others)
comparison_data <- comparison_data[order(comparison_data$connection_type), ]
comparison_data$connection_type <- factor(comparison_data$connection_type, 
                                         levels = c("Indirect", "DNa03-direct", "DNa06-direct", "Both-direct"))

# Comparison plot with La Croix inspired colors
g2 <- ggplot(comparison_data, aes(x = adjusted_influenceDNa03, y = adjusted_influenceDNa06, 
                                 color = connection_type)) +
  geom_point(alpha = 0.7) +
  scale_color_manual(values = c("Indirect" = "#808080",           # Grey
                               "DNa03-direct" = "#FF6B9D",       # Pamplemousse Pink
                               "DNa06-direct" = "#4ECDC4",       # Key Lime
                               "Both-direct" = "#FFE66D")) +     # Lemon Yellow
  geom_abline(slope = 1, intercept = 0, color = "black", linetype = "dashed", alpha = 0.5) +
  labs(title = "DNa03 vs DNa06 Influence Comparison",
       subtitle = "Comparing influence patterns between different descending neuron types",
       x = "Adjusted Influence (DNa03)",
       y = "Adjusted Influence (DNa06)",
       color = "Connection type") +
  theme_minimal() +
  coord_equal()

print(g2)

# Save plot
ggsave(g2, 
      file = "inst/images/banc_dna03_vs_dna06_influence.png", 
      height = 6, 
      width = 8)

# Calculate correlation between the two cell types
correlation <- cor(comparison_data$adjusted_influenceDNa03, 
                   comparison_data$adjusted_influenceDNa06)
cat("Correlation between DNa03 and DNa06 influence patterns:", round(correlation, 4), "\n")
```

## Understanding the Results

The visualization shows how DNa03 neurons influence other descending neurons in the network. Key observations:

1. **Direct connections** (red) show higher influence scores, as expected
2. **Indirect connections** (blue) still show measurable influence through multi-synaptic pathways
3. The **adjusted influence** score (`log(influence) + 24`) provides a meaningful scale where:
   - Scores near 0 indicate minimal influence
   - Higher scores indicate stronger influence through the network dynamics

## Implementation Comparison

The `influencer` package provides both R and Python implementations. Here's how you might compare them:

```{r implementation_comparison, eval=FALSE, fig.width=10, fig.height=8}
# Python implementation (real comparison, no simulation)
# Python implementation with automatic environment management
system.time({
  ic.dns.py <- influence_calculator_py(edgelist_simple = edges.table, meta = banc.meta)
})

# Time both implementations
cat("Running R implementation for comparison...\n")
system.time({
  dna03.influence.r <- ic.dns$calculate_influence(dna03.ids) 
})

cat("Running Python implementation for comparison...\n")
system.time({
  dna03.influence.py <- calculate_influence_py(ic.dns.py, dna03.ids)
})

# Compare the results - create a comparison plot
# Merge results for comparison
python_comparison_data <- merge(
  dna03.influence.r[, c("id", "adjusted_influence")],
  dna03.influence.py[, c("id", "adjusted_influence")],
  by = "id",
  suffixes = c("_R", "_Python")
)

# Add direct connection information
python_comparison_data$directly_connected <- python_comparison_data$id %in% dna03.post.ids

# Order data frame so indirect points are plotted first
python_comparison_data <- python_comparison_data[order(!python_comparison_data$directly_connected), ]

# Comparison plot with direct connection coloring
subtitle_text <- "Real comparison between R and Python implementations"

g3 <- ggplot(python_comparison_data, aes(x = adjusted_influence_R, y = adjusted_influence_Python,
                                        color = directly_connected)) +
  geom_point(alpha = 0.7) +
  scale_color_manual(values = c("FALSE" = "#007BC3", "TRUE" = "#EE4244"),
                    labels = c("indirectly connected", "directly connected")) +
  geom_abline(slope = 1, intercept = 0, color = "black", linetype = "dashed", alpha = 0.5) +
  labs(title = "R vs Python Implementation Comparison",
       subtitle = subtitle_text,
       x = "Adjusted Influence (R implementation)",
       y = "Adjusted Influence (Python implementation)",
       color = "Connection type") +
  theme_minimal() +
  coord_equal()

print(g3)

# Save plot
ggsave(g3, 
      file = "inst/images/banc_dna03_influence_r_vs_python.png", 
      height = 6, 
      width = 8)

# Calculate correlation
python_correlation <- cor(python_comparison_data$adjusted_influence_R, 
                         python_comparison_data$adjusted_influence_Python)
cat("Correlation between R and Python implementations:", round(python_correlation, 4), "\n")
```

## Advanced Usage Notes

This vignette demonstrates the complete workflow using real BANC connectome data. The approach shown here:

- **Uses the full connectome**: Rather than subsetting to specific neuron types, we use the complete connectivity matrix for more accurate influence calculations
- **Demonstrates caching**: Shows how the R implementation's smart caching dramatically speeds up subsequent calculations  
- **Highlights biological patterns**: Direct vs indirect connections show distinct influence patterns
- **Compares implementations**: Shows the high correlation between R and Python methods

For very large datasets, consider using subsets during development and testing, then scaling to the full connectome for final analyses.

## Key Features of the R Implementation

The native R implementation provides several advantages:

1. **Performance**: 4x speed improvement through caching and smart routing
2. **No dependencies**: Pure R with optimized sparse matrix operations
3. **Flexibility**: Works with data frames (recommended) or SQLite databases
4. **Reproducible**: Deterministic results without environment conflicts

## Conclusion

The `influencer` package provides powerful tools for analyzing connectome influence using linear dynamical models. The native R implementation is recommended for most users due to its performance, reliability, and seamless integration with R data analysis workflows.

For more information and real-world examples, see the package documentation and the original research papers describing the mathematical framework.

## Session Information

```{r session_info}
sessionInfo()
```

